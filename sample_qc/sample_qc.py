import argparse
import logging
import math
from typing import Any, List, Tuple, Optional, Dict

import hail as hl

from gnomad.utils.sparse_mt import filter_ref_blocks
from gnomad.utils.filtering import (
    add_filters_expr,
    filter_low_conf_regions,
    filter_to_autosomes,)
from gnomad.utils.reference_genome import get_reference_genome
from gnomad.sample_qc.sex import get_ploidy_cutoffs
from gnomad.utils.annotations import bi_allelic_expr, get_adj_expr
from gnomad.resources.grch38.reference_data import telomeres_and_centromeres
telomeres_and_centromeres.path = 'gs://gnomad-public-requester-pays/resources/grch38/telomeres_and_centromeres/hg38.telomeresAndMergedCentromeres.ht'

logging.basicConfig(format="%(levelname)s (%(name)s %(lineno)s): %(message)s")
logger = logging.getLogger("sample_qc")
logger.setLevel(logging.INFO)

ccdg_bucket = 'gs://ccdg'

def get_sample_qc_root(data_type: str = 'genomes', mt: bool = False) -> str:
    """
    Return path to sample QC root folder
    :param data_type: Whether data is from genomes or exomes, default is genomes
    :param mt: Whether path is for a MatrixTable, default is False
    :return: Root to sample QC path
    """
    return f"{ccdg_bucket}/sample_qc/{'mt' if mt else 'ht'}/{data_type}"

def get_vds_path(data_type: str = 'genomes'):
    data_type = '136k' if data_type == 'genomes' else '200k_ccdg_exome'
    return f'{ccdg_bucket}/vds/split_{data_type}.vds'

def get_qc_ht_path(data_type: str = 'genomes'):
    return f"{get_sample_qc_root(data_type=data_type, mt=False)}/ccdg_{data_type}_qc.ht"

def get_sample_qc_ht_path(data_type: str = 'genomes', strat: str = "all"):
    """
    Gets sample QC annotations generated by Hail for the specified stratification:
        - bi_allelic
        - multi_allelic
        - all
    :param data_type: Whether data is from genomes or exomes, default is genomes
    :param strat: Which stratification to return
    :return: Sample QC table
    """
    return f"{get_sample_qc_root(data_type=data_type, mt=False)}/sample_qc_{strat}.ht"

def get_sex_ht_path(data_type = 'genomes'):
    return f"{get_sample_qc_root(data_type=data_type, mt=False)}/{data_type}_sex.ht"

# Filter to bi-allelic, high-callrate, common SNPs for sample QC
def hard_filter_var_ht(vds):
    var_mt = vds.variant_data
    var_mt = var_mt.filter_rows((hl.len(var_mt.alleles) == 2) & hl.is_snp(var_mt.alleles[0], var_mt.alleles[1]))
    var_mt = var_mt.annotate_entries(GT=hl.experimental.lgt_to_gt(var_mt.LGT, var_mt.LA))
    var_ht = var_mt.filter_rows((hl.agg.mean(var_mt.GT.n_alt_alleles()) / 2 > 0.001) &
                                (hl.agg.fraction(hl.is_defined(var_mt.GT)) > 0.99)).rows()
    return var_ht

## TODO: add options - remove hard filtered samples, sex imputed data...
def get_qc_vds(
        data_type: str = 'genomes',
        split: bool = False,
        key_by_locus_and_alleles: bool = False,
) -> hl.vds:
    vds = hl.vds.read_vds(get_vds_path(data_type))
    var_ht = hl.read_table(get_qc_ht_path(data_type))
    vds = hl.vds.filter_variants(vds, var_ht, keep=True)

    if split:
        vds.variant_data = vds.variant_data.annotate_rows(
            n_unsplit_alleles=hl.len(vds.variant_data.alleles),
            mixed_site=(hl.len(vds.variant_data.alleles) > 2)
                       & hl.any(lambda a: hl.is_indel(vds.variant_data.alleles[0], a), vds.variant_data.alleles[1:])
                       & hl.any(lambda a: hl.is_snp(vds.variant_data.alleles[0], a), vds.variant_data.alleles[1:]),
        )
        vds = hl.vds.split_multi(vds, filter_changed_loci=True)

    if key_by_locus_and_alleles:
        vds.variant_data = hl.MatrixTable(
            hl.ir.MatrixKeyRowsBy(
                vds.variant_data._mir, ["locus", "alleles"], is_sorted=True
            )  # Prevents hail from running sort on genotype MT which is already sorted by a unique locus
        )
    return vds

################## Compute sample qc #####################
# Modified: from gnomad.sample_qc.filtering import compute_stratified_sample_qc
# https://github.com/broadinstitute/gnomad_methods/blob/35066ffc01d63ac2d7b20e069ea6703013ae9da7/gnomad/sample_qc/filtering.py#L184
def compute_stratified_sample_qc(
    vds: hl.vds,
    strata: Dict[str, hl.expr.BooleanExpression],
    tmp_ht_prefix: Optional[str],
    gt_col: Optional[str] = None,
) -> hl.Table:
    """
    Run hl.sample_qc on different strata and then also merge the results into a single expression.
    .. note::
        Strata should be non-overlapping, e.g. SNV vs indels or bi-allelic vs multi-allelic
    :param vds: Input vds
    :param strata: Strata names and filtering expressions
    :param tmp_ht_prefix: Optional path prefix to write the intermediate strata results to (recommended for larger datasets)
    :param gt_col: Name of entry field storing the genotype. Default: 'GT'
    :return: Sample QC table, including strat-specific numbers
    """
    mt = vds.variant_data
    mt = mt.select_rows(**strata)

    if gt_col is not None:
        mt = mt.select_entries(GT=mt[gt_col])
    else:
        mt = mt.select_entries("GT")

    strat_hts = {}
    for strat in strata:
        var_ht = mt.filter_rows(mt[strat]).rows()
        strat_sample_qc_ht = hl.vds.sample_qc(hl.vds.filter_variants(vds, var_ht))
        if tmp_ht_prefix is not None:
            strat_sample_qc_ht = strat_sample_qc_ht.checkpoint(
                tmp_ht_prefix + f"_{strat}.ht", overwrite=True
            )
        else:
            strat_sample_qc_ht = strat_sample_qc_ht.persist()
        strat_hts[strat] = strat_sample_qc_ht

    sample_qc_ht = strat_hts.pop(list(strata)[0])
    sample_qc_ht = sample_qc_ht.select(
        **{f"{list(strata)[0]}_sample_qc": sample_qc_ht.sample_qc},
        **{
            f"{strat}_sample_qc": strat_hts[strat][sample_qc_ht.key].sample_qc
            for strat in list(strata)[1:]
        },
    )
    sample_qc_ht = sample_qc_ht.annotate(
        sample_qc=merge_sample_qc_expr(list(sample_qc_ht.row_value.values()))
    )

    return sample_qc_ht

# Modified: https://github.com/broadinstitute/gnomad_qc/blob/4fbc24031ea621162182fc05ca51e464b15a543d/gnomad_qc/v3/sample_qc/sample_qc.py#L88
def compute_sample_qc(data_type='exomes') -> hl.Table:
    """
    Perform sample QC on the raw split matrix table using `compute_stratified_sample_qc`.
    :param data_type: Whether data is from genomes or exomes, default is genomes
    :return: Table containing sample QC metrics
    :rtype: hl.Table
    """
    logger.info("Computing sample QC")

    vds = get_qc_vds(
        data_type=data_type,
        split=True,
        key_by_locus_and_alleles=True,
    )

    var_ht = filter_to_autosomes(vds.variant_data).rows()
    vds = hl.vds.filter_variants(vds, var_ht)
    vds.variant_data = vds.variant_data.select_entries("GT", "GQ")

    # Filter reference blocks
    ref_ht = filter_ref_blocks(vds.variant_data).rows()
    vds = hl.vds.filter_variants(vds, ref_ht, keep=True)

    # Remove centromeres and telomeres incase they were included
    if data_type == 'genomes':
        low_conf_ht = filter_low_conf_regions(
            vds.variant_data,
            filter_lcr=False,
            filter_decoy=False,
            filter_segdup=False,
            filter_telomeres_and_centromeres=True,
        ).rows()
        vds = hl.vds.filter_variants(vds, low_conf_ht, keep=True)

    sample_qc_ht = compute_stratified_sample_qc(
        vds,
        strata={
            "bi_allelic": bi_allelic_expr(vds.variant_data),
            "multi_allelic": ~bi_allelic_expr(vds.variant_data),
        },
        tmp_ht_prefix=get_sample_qc_ht_path(data_type)[:-7],
    )

    return sample_qc_ht.repartition(100)

################## Impute sex #####################
# Modified: from gnomad.utils.sparse_mt import impute_sex_ploidy
# https://github.com/broadinstitute/gnomad_methods/blob/32b3c1d50d3faf300597528272f8efd6973b37e4/gnomad/utils/sparse_mt.py#L545
def impute_sex_ploidy(
        vds: hl.vds,
        excluded_calling_intervals: Optional[hl.Table] = None,
        included_calling_intervals: Optional[hl.Table] = None,
        normalization_contig: str = "chr20",
        chr_x: Optional[str] = None,
        chr_y: Optional[str] = None,
) -> hl.Table:
    """
    Impute sex ploidy from a sparse MatrixTable.
    Sex ploidy is imputed by normalizing the coverage of chromosomes X and Y using the coverage of an autosomal
    chromosome (by default chr20).
    Coverage is computed using the median block coverage (summed over the block size) and the non-ref coverage at
    non-ref genotypes.
    :param vds: Input vds
    :param excluded_calling_intervals: Optional table of intervals to exclude from the computation.
        Used only when determining contig size (not used when computing chromosome depth).
    :param included_calling_intervals: Optional table of intervals to use in the computation.
        Used only when determining contig size (not used when computing chromosome depth).
    :param normalization_contig: Which chromosome to normalize by
    :param chr_x: Optional X Chromosome contig name (by default uses the X contig in the reference)
    :param chr_y: Optional Y Chromosome contig name (by default uses the Y contig in the reference)
    :return: Table with mean coverage over chromosomes 20, X and Y and sex chromosomes ploidy based on normalized coverage.
    """

    ref = get_reference_genome(vds.variant_data.locus, add_sequence=True)
    if chr_x is None:
        if len(ref.x_contigs) != 1:
            raise NotImplementedError(
                "Found {0} X chromosome contigs ({1}) in Genome reference. sparse_impute_sex_ploidy currently only supports a single X chromosome contig. Please use the `chr_x` argument to  specify which X chromosome contig to use ".format(
                    len(ref.x_contigs), ",".join(ref.x_contigs)
                )
            )
        chr_x = ref.x_contigs[0]
    if chr_y is None:
        if len(ref.y_contigs) != 1:
            raise NotImplementedError(
                "Found {0} Y chromosome contigs ({1}) in Genome reference. sparse_impute_sex_ploidy currently only supports a single Y chromosome contig. Please use the `chr_y` argument to  specify which Y chromosome contig to use ".format(
                    len(ref.y_contigs), ",".join(ref.y_contigs)
                )
            )
        chr_y = ref.y_contigs[0]

    def get_contig_size(contig: str) -> int:
        logger.info("Working on %s", contig)
        contig_ht = hl.utils.range_table(
            ref.contig_length(contig),
            n_partitions=int(ref.contig_length(contig) / 500_000),
        )
        contig_ht = contig_ht.annotate(
            locus=hl.locus(contig=contig, pos=contig_ht.idx + 1, reference_genome=ref)
        )
        contig_ht = contig_ht.filter(contig_ht.locus.sequence_context().lower() != "n")

        if contig in ref.x_contigs:
            contig_ht = contig_ht.filter(contig_ht.locus.in_x_nonpar())
        if contig in ref.y_contigs:
            contig_ht = contig_ht.filter(contig_ht.locus.in_y_nonpar())

        contig_ht = contig_ht.key_by("locus")
        if included_calling_intervals is not None:
            contig_ht = contig_ht.filter(
                hl.is_defined(included_calling_intervals[contig_ht.key])
            )
        if excluded_calling_intervals is not None:
            contig_ht = contig_ht.filter(
                hl.is_missing(excluded_calling_intervals[contig_ht.key])
            )
        contig_size = contig_ht.count()
        logger.info("Contig %s has %d bases for coverage.", contig, contig_size)
        return contig_size

    def get_chr_dp_ann(chrom: str) -> hl.Table:
        contig_size = get_contig_size(chrom)
        chr_mt = hl.vds.filter_intervals(vds,
                                         [hl.parse_locus_interval(chrom, reference_genome='GRCh38')]
                                         ).variant_data

        if chrom in ref.x_contigs:
            chr_mt = chr_mt.filter_rows(chr_mt.locus.in_x_nonpar())
        if chrom in ref.y_contigs:
            chr_mt = chr_mt.filter_rows(chr_mt.locus.in_y_nonpar())

        return chr_mt.select_cols(
            **{
                f"{chrom}_mean_dp": hl.agg.sum(
                    hl.cond(
                        chr_mt.LGT.is_hom_ref(),
                        chr_mt.DP * (1 + chr_mt.END - chr_mt.locus.position),
                        chr_mt.DP,
                    )
                )
                                    / contig_size
            }
        ).cols()

    normalization_chrom_dp = get_chr_dp_ann(normalization_contig)
    chrX_dp = get_chr_dp_ann(chr_x)
    chrY_dp = get_chr_dp_ann(chr_y)

    ht = normalization_chrom_dp.annotate(
        **chrX_dp[normalization_chrom_dp.key], **chrY_dp[normalization_chrom_dp.key],
    )

    return ht.annotate(
        **{
            f"{chr_x}_ploidy": ht[f"{chr_x}_mean_dp"]
                               / (ht[f"{normalization_contig}_mean_dp"] / 2),
            f"{chr_y}_ploidy": ht[f"{chr_y}_mean_dp"]
                               / (ht[f"{normalization_contig}_mean_dp"] / 2),
        }
    )

# Modified: from gnomad.sample_qc.pipeline import annotate_sex
# https://github.com/broadinstitute/gnomad_methods/blob/32b3c1d50d3faf300597528272f8efd6973b37e4/gnomad/sample_qc/pipeline.py#L211
def annotate_sex(
    vds: hl.vds,
    is_sparse: bool = True,
    excluded_intervals: Optional[hl.Table] = None,
    included_intervals: Optional[hl.Table] = None,
    normalization_contig: str = "chr20",
    sites_ht: Optional[hl.Table] = None,
    aaf_expr: Optional[str] = None,
    gt_expr: str = "GT",
    f_stat_cutoff: float = 0.5,
    aaf_threshold: float = 0.001,
) -> hl.Table:
    """
    Impute sample sex based on X-chromosome heterozygosity and sex chromosome ploidy.
    Return Table with the following fields:
        - s (str): Sample
        - chr20_mean_dp (float32): Sample's mean coverage over chromosome 20.
        - chrX_mean_dp (float32): Sample's mean coverage over chromosome X.
        - chrY_mean_dp (float32): Sample's mean coverage over chromosome Y.
        - chrX_ploidy (float32): Sample's imputed ploidy over chromosome X.
        - chrY_ploidy (float32): Sample's imputed ploidy over chromosome Y.
        - f_stat (float64): Sample f-stat. Calculated using hl.impute_sex.
        - n_called (int64): Number of variants with a genotype call. Calculated using hl.impute_sex.
        - expected_homs (float64): Expected number of homozygotes. Calculated using hl.impute_sex.
        - observed_homs (int64): Expected number of homozygotes. Calculated using hl.impute_sex.
        - X_karyotype (str): Sample's chromosome X karyotype.
        - Y_karyotype (str): Sample's chromosome Y karyotype.
        - sex_karyotype (str): Sample's sex karyotype.
    :param vds: Input vds
    :param bool is_sparse: Whether input MatrixTable is in sparse data format
    :param excluded_intervals: Optional table of intervals to exclude from the computation.
    :param included_intervals: Optional table of intervals to use in the computation. REQUIRED for exomes.
    :param normalization_contig: Which chromosome to use to normalize sex chromosome coverage. Used in determining sex chromosome ploidies.
    :param sites_ht: Optional Table to use. If present, filters input MatrixTable to sites in this Table prior to imputing sex,
                    and pulls alternate allele frequency from this Table.
    :param aaf_expr: Optional. Name of field in input MatrixTable with alternate allele frequency.
    :param gt_expr: Name of entry field storing the genotype. Default: 'GT'
    :param f_stat_cutoff: f-stat to roughly divide 'XX' from 'XY' samples. Assumes XX samples are below cutoff and XY are above cutoff.
    :param float aaf_threshold: Minimum alternate allele frequency to be used in f-stat calculations.
    :return: Table of samples and their imputed sex karyotypes.
    """
    logger.info("Imputing sex chromosome ploidies...")

    if is_sparse:
        ploidy_ht = impute_sex_ploidy(
            vds, excluded_intervals, included_intervals, normalization_contig
        )
    else:
        raise NotImplementedError(
            "Imputing sex ploidy does not exist yet for dense data."
        )

    x_contigs = get_reference_genome(vds.variant_data.locus).x_contigs
    logger.info("Filtering mt to biallelic SNPs in X contigs: %s", x_contigs)
    if "was_split" in list(mt.row):
        var_ht = mt.filter_rows((~mt.was_split) & hl.is_snp(mt.alleles[0], mt.alleles[1])).rows()
        vds = hl.vds.filter_variants(vds, var_ht)
    else:
        var_ht = mt.filter_rows(
            (hl.len(mt.alleles) == 2) & hl.is_snp(mt.alleles[0], mt.alleles[1])
        ).rows()
        vds = hl.vds.filter_variants(vds, var_ht)
    vds = hl.vds.filter_intervals(
        vds, [hl.parse_locus_interval(contig, reference_genome='GRCh38') for contig in x_contigs]
    )

    if sites_ht is not None:
        if aaf_expr == None:
            logger.warning(
                "sites_ht was provided, but aaf_expr is missing. Assuming name of field with alternate allele frequency is 'AF'."
            )
            aaf_expr = "AF"
        logger.info("Filtering to provided sites")
        mt = vds.variant_data
        var_mt = mt.annotate_rows(**sites_ht[mt.row_key])
        var_ht = var_mt.filter_rows(hl.is_defined(var_mt[aaf_expr])).rows()
        vds = hl.vds.filter_variants(vds, var_ht)

    logger.info("Calculating inbreeding coefficient on chrX")
    mt = vds.variant_data
    #### hl.impute_sex -> vds version?
    sex_ht = hl.impute_sex(
        mt[gt_expr],
        aaf_threshold=aaf_threshold,
        male_threshold=f_stat_cutoff,
        female_threshold=f_stat_cutoff,
        aaf=aaf_expr,
    )

    logger.info("Annotating sex ht with sex chromosome ploidies")
    sex_ht = sex_ht.annotate(**ploidy_ht[sex_ht.key])

    logger.info("Inferring sex karyotypes")
    x_ploidy_cutoffs, y_ploidy_cutoffs = get_ploidy_cutoffs(sex_ht, f_stat_cutoff)
    sex_ht = sex_ht.annotate_globals(
        x_ploidy_cutoffs=hl.struct(
            upper_cutoff_X=x_ploidy_cutoffs[0],
            lower_cutoff_XX=x_ploidy_cutoffs[1][0],
            upper_cutoff_XX=x_ploidy_cutoffs[1][1],
            lower_cutoff_XXX=x_ploidy_cutoffs[2],
        ),
        y_ploidy_cutoffs=hl.struct(
            lower_cutoff_Y=y_ploidy_cutoffs[0][0],
            upper_cutoff_Y=y_ploidy_cutoffs[0][1],
            lower_cutoff_YY=y_ploidy_cutoffs[1],
        ),
        f_stat_cutoff=f_stat_cutoff,
    )
    return sex_ht.annotate(
        **get_sex_expr(
            sex_ht.chrX_ploidy, sex_ht.chrY_ploidy, x_ploidy_cutoffs, y_ploidy_cutoffs
        )
    )

# Modified: https://github.com/broadinstitute/gnomad_qc/blob/4fbc24031ea621162182fc05ca51e464b15a543d/gnomad_qc/v3/sample_qc/sample_qc.py#L294
def compute_sex(
    data_type: str = 'genomes',
    aaf_threshold: float = 0.001,
    f_stat_cutoff: float = 0.5
) -> hl.Table:
    """
    Impute sample sex based on X-chromosome heterozygosity and sex chromosome ploidy.
    Allele frequencies from v3.0 are used to prevent the need to densify the current version's sparse MT.
    :param vds: Input vds
    :param aaf_threshold: Minimum alternate allele frequency to be used in f-stat calculations.
    :param f_stat_cutoff: f-stat to roughly divide 'XX' from 'XY' samples. Assumes XX samples are below cutoff and XY are above cutoff.
    :return: Table with inferred sex annotation
    :rtype: hl.Table
    """
    vds = get_qc_vds(
        data_type=data_type,
        key_by_locus_and_alleles=True,
    )

#     # Use AF from v3
#     freq_ht = freq.versions["3"].ht()
#     freq_ht = freq_ht.select(AF=freq_ht.freq[0].AF) ------------------?
#     freq_ht = freq_ht.filter(freq_ht.AF > aaf_threshold)

    sex_ht = annotate_sex(
        vds,
        excluded_intervals=telomeres_and_centromeres.ht(),
        aaf_threshold=aaf_threshold,
        f_stat_cutoff=f_stat_cutoff,
#       sites_ht=freq_ht,
#       aaf_expr="AF",
        gt_expr="LGT",
    )

    return sex_ht

def main(args):
    hl.init(log='/sample_qc.log')
    data_type = "genomes" if args.genomes else "exomes"

    if args.regenerate_qc_ht:
        vds = hl.vds.read_vds(get_vds_path(data_type))
        hard_filter_var_ht(vds).checkpoint(get_qc_ht_path(data_type), overwrite=args.overwrite)

    if args.compute_sample_qc:
        compute_sample_qc(data_type).write(get_sample_qc_ht_path(data_type), overwrite=args.overwrite)

    if args.impute_sex:
        compute_sex(data_type).write(get_sex_ht_path(data_type), overwrite=args.overwrite)

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('--exomes',
                        help='Input MatrixTable contains exomes. One of --exomes or --genomes is required.',
                        action='store_true')
    parser.add_argument('--genomes',
                        help='Input MatrixTable contains genomes. One of --exomes or --genomes is required.',
                        action='store_true')
    parser.add_argument(
        "--overwrite",
        help="Overwrite all data from this subset (default: False)",
        action="store_true",
    )
    parser.add_argument(
        "--regenerate_qc_ht",
        help='Regenerate QC tables',
        action='store_true')
    parser.add_argument(
        "--compute_sample_qc",
        help="Compute sample QC metrics",
        action="store_true"
    )

    args = parser.parse_args()

    # if args.slack_channel:
    #     try_slack(args.slack_channel, main, args)
    # else:
    main(args)
