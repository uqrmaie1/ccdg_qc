import argparse
import logging
import math
from typing import Any, List, Tuple, Optional, Dict

import hail as hl

from gnomad.utils.sparse_mt import filter_ref_blocks
from gnomad.utils.filtering import (
    add_filters_expr,
    filter_low_conf_regions,
    filter_to_autosomes,)
from gnomad.utils.reference_genome import get_reference_genome
from gnomad.sample_qc.sex import get_ploidy_cutoffs
from gnomad.utils.annotations import bi_allelic_expr, get_adj_expr

logging.basicConfig(format="%(levelname)s (%(name)s %(lineno)s): %(message)s")
logger = logging.getLogger("sample_qc")
logger.setLevel(logging.INFO)

ccdg_bucket = 'gs://ccdg'

def get_sample_qc_root(data_type: str = 'genomes', mt: bool = False) -> str:
    """
    Return path to sample QC root folder
    :param data_type: Whether data is from genomes or exomes, default is genomes
    :param mt: Whether path is for a MatrixTable, default is False
    :return: Root to sample QC path
    """
    return f"{ccdg_bucket}/sample_qc/{'mt' if mt else 'ht'}/{data_type}"

def get_vds_path(data_type: str = 'genomes'):
    data_type = '136k' if data_type == 'genomes' else '200k_ccdg_exome'
    return f'{ccdg_bucket}/vds/split_{data_type}.vds'

def get_qc_ht_path(data_type: str = 'genomes'):
    return f"{get_sample_qc_root(data_type=data_type, mt=False)}/ccdg_{data_type}_qc.ht"

def get_sample_qc_ht_path(data_type: str = 'genomes'):
    return f"{get_sample_qc_root(data_type=data_type, mt=False)}/ccdg_{data_type}_sample_qc.ht"

def get_sample_qc_ht_path(data_type: str = 'genomes', strat: str = "all"):
    """
    Gets sample QC annotations generated by Hail for the specified stratification:
        - bi_allelic
        - multi_allelic
        - all
    :param data_type: Whether data is from genomes or exomes, default is genomes
    :param strat: Which stratification to return
    :return: Sample QC table
    """
    return f"{get_sample_qc_root(data_type=data_type, mt=False)}/sample_qc_{strat}.ht"

# Filter to bi-allelic, high-callrate, common SNPs for sample QC
def hard_filter_var_ht(vds):
    var_mt = vds.variant_data
    var_mt = var_mt.filter_rows((hl.len(var_mt.alleles) == 2) & hl.is_snp(var_mt.alleles[0], var_mt.alleles[1]))
    var_mt = var_mt.annotate_entries(GT=hl.experimental.lgt_to_gt(var_mt.LGT, var_mt.LA))
    var_ht = var_mt.filter_rows((hl.agg.mean(var_mt.GT.n_alt_alleles()) / 2 > 0.001) &
                                (hl.agg.fraction(hl.is_defined(var_mt.GT)) > 0.99)).rows()
    return var_ht

## TODO: add options - remove hard filtered samples, sex imputed data...
def get_qc_vds(
        data_type: str = 'genomes',
        split: bool = False,
        key_by_locus_and_alleles: bool = False,
) -> hl.vds:
    vds = hl.vds.read_vds(get_vds_path(data_type))
    var_ht = hl.read_table(get_qc_ht_path(data_type))
    vds = hl.vds.filter_variants(vds, var_ht, keep=True)

    if split:
        vds.variant_data = vds.variant_data.annotate_rows(
            n_unsplit_alleles=hl.len(vds.variant_data.alleles),
            mixed_site=(hl.len(vds.variant_data.alleles) > 2)
                       & hl.any(lambda a: hl.is_indel(vds.variant_data.alleles[0], a), vds.variant_data.alleles[1:])
                       & hl.any(lambda a: hl.is_snp(vds.variant_data.alleles[0], a), vds.variant_data.alleles[1:]),
        )
        vds = hl.vds.split_multi(vds, filter_changed_loci=True)

    if key_by_locus_and_alleles:
        vds.variant_data = hl.MatrixTable(
            hl.ir.MatrixKeyRowsBy(
                vds.variant_data._mir, ["locus", "alleles"], is_sorted=True
            )  # Prevents hail from running sort on genotype MT which is already sorted by a unique locus
        )
    return vds

def compute_stratified_sample_qc(
    vds: hl.vds,
    strata: Dict[str, hl.expr.BooleanExpression],
    tmp_ht_prefix: Optional[str],
    gt_col: Optional[str] = None,
) -> hl.Table:
    """
    Run hl.sample_qc on different strata and then also merge the results into a single expression.
    .. note::
        Strata should be non-overlapping, e.g. SNV vs indels or bi-allelic vs multi-allelic
    :param vds: Input vds
    :param strata: Strata names and filtering expressions
    :param tmp_ht_prefix: Optional path prefix to write the intermediate strata results to (recommended for larger datasets)
    :param gt_col: Name of entry field storing the genotype. Default: 'GT'
    :return: Sample QC table, including strat-specific numbers
    """
    mt = vds.variant_data
    mt = mt.select_rows(**strata)

    if gt_col is not None:
        mt = mt.select_entries(GT=mt[gt_col])
    else:
        mt = mt.select_entries("GT")

    strat_hts = {}
    for strat in strata:
        var_ht = mt.filter_rows(mt[strat]).rows()
        strat_sample_qc_ht = hl.vds.sample_qc(hl.vds.filter_variants(vds, var_ht))
        if tmp_ht_prefix is not None:
            strat_sample_qc_ht = strat_sample_qc_ht.checkpoint(
                tmp_ht_prefix + f"_{strat}.ht", overwrite=True
            )
        else:
            strat_sample_qc_ht = strat_sample_qc_ht.persist()
        strat_hts[strat] = strat_sample_qc_ht

    sample_qc_ht = strat_hts.pop(list(strata)[0])
    sample_qc_ht = sample_qc_ht.select(
        **{f"{list(strata)[0]}_sample_qc": sample_qc_ht.sample_qc},
        **{
            f"{strat}_sample_qc": strat_hts[strat][sample_qc_ht.key].sample_qc
            for strat in list(strata)[1:]
        },
    )
    sample_qc_ht = sample_qc_ht.annotate(
        sample_qc=merge_sample_qc_expr(list(sample_qc_ht.row_value.values()))
    )

    return sample_qc_ht


def compute_sample_qc(data_type='exomes') -> hl.Table:
    """
    Perform sample QC on the raw split matrix table using `compute_stratified_sample_qc`.
    :param data_type: Whether data is from genomes or exomes, default is genomes
    :return: Table containing sample QC metrics
    :rtype: hl.Table
    """
    logger.info("Computing sample QC")

    vds = get_qc_vds(
        data_type=data_type,
        split=True,
        key_by_locus_and_alleles=True,
    )

    var_ht = filter_to_autosomes(vds.variant_data).rows()
    vds = hl.vds.filter_variants(vds, var_ht)
    vds.variant_data = vds.variant_data.select_entries("GT", "GQ")

    # Filter reference blocks
    ref_ht = filter_ref_blocks(vds.variant_data).rows()
    vds = hl.vds.filter_variants(vds, ref_ht, keep=True)

    # Remove centromeres and telomeres incase they were included
    if data_type == 'genomes':
        low_conf_ht = filter_low_conf_regions(
            vds.variant_data,
            filter_lcr=False,
            filter_decoy=False,
            filter_segdup=False,
            filter_telomeres_and_centromeres=True,
        ).rows()
        vds = hl.vds.filter_variants(vds, low_conf_ht, keep=True)

    sample_qc_ht = compute_stratified_sample_qc(
        vds,
        strata={
            "bi_allelic": bi_allelic_expr(vds.variant_data),
            "multi_allelic": ~bi_allelic_expr(vds.variant_data),
        },
        tmp_ht_prefix=get_sample_qc_ht_path(data_type)[:-7],
    )

    return sample_qc_ht.repartition(100)

def main(args):
    hl.init(log='/sample_qc.log')
    data_type = "genomes" if args.genomes else "exomes"

    if args.regenerate_qc_ht:
        vds = hl.vds.read_vds(get_vds_path(data_type))
        hard_filter_var_ht(vds).checkpoint(get_qc_ht_path(data_type), overwrite=args.overwrite)

    if args.compute_sample_qc:
        compute_sample_qc(data_type).write(get_sample_qc_ht_path(data_type), overwrite=args.overwrite)


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('--exomes',
                        help='Input MatrixTable contains exomes. One of --exomes or --genomes is required.',
                        action='store_true')
    parser.add_argument('--genomes',
                        help='Input MatrixTable contains genomes. One of --exomes or --genomes is required.',
                        action='store_true')
    parser.add_argument(
        "--overwrite",
        help="Overwrite all data from this subset (default: False)",
        action="store_true",
    )
    parser.add_argument(
        "--regenerate_qc_ht",
        help='Regenerate QC tables',
        action='store_true')
    parser.add_argument(
        "--compute_sample_qc",
        help="Compute sample QC metrics",
        action="store_true"
    )

    args = parser.parse_args()

    # if args.slack_channel:
    #     try_slack(args.slack_channel, main, args)
    # else:
    main(args)
